<?php

declare(strict_types=1);

/*
 * ShellEVLib
 *
 * This file was automatically generated by APIMATIC v3.0 ( https://www.apimatic.io ).
 */

namespace ShellEVLib\Controllers;

use Core\Request\Parameters\HeaderParam;
use Core\Request\Parameters\QueryParam;
use Core\Request\Parameters\TemplateParam;
use Core\Response\Types\ErrorType;
use CoreInterfaces\Core\Request\RequestMethod;
use ShellEVLib\Exceptions\ApiException;
use ShellEVLib\Exceptions\BadRequestException;
use ShellEVLib\Exceptions\NotFoundException;
use ShellEVLib\Exceptions\UnauthorizedException;
use ShellEVLib\Models\GetLocationsListAuthorizationMethodsEnum;
use ShellEVLib\Models\GetLocationsListConnectorTypesEnum;
use ShellEVLib\Models\GetLocationsListEvseStatusEnum;
use ShellEVLib\Models\GetMarkersListAuthorizationMethodsEnum;
use ShellEVLib\Models\GetMarkersListConnectorTypesEnum;
use ShellEVLib\Models\GetMarkersListEvseStatusEnum;
use ShellEVLib\Models\GetNearbyLocationsAuthorizationMethodsEnum;
use ShellEVLib\Models\GetNearbyLocationsConnectorTypesEnum;
use ShellEVLib\Models\GetNearbyLocationsEvseStatusEnum;
use ShellEVLib\Models\LocationResponeObject;
use ShellEVLib\Models\MultiLocationMarker;
use ShellEVLib\Models\SingleLocationMarker;

class LocationsController extends BaseController
{
    /**
     * This API provides the list of all Shell Recharge locations. The list includes all Shell Recharge
     * network and all locations available through our roaming partners.The end point provides flexible
     * search criteria in order to get the list of Shell Recharge Network. The end point provides the
     * details such as the exact location/address of the site along with the up-to-date status information
     * of all the charging units in the site.
     *
     * Supported Search Options
     *
     * * Based on status of the Charging units. Eg : Available or Occupied
     * * Based on available connector types.
     * * Based on minimum Power output (in kW) available
     * * Based on a specific charging unit ID (EVSE ID)
     *
     * @param string $requestId A unique request id in GUID format. The value is written to the
     *        Shell API Platform audit log for end to end traceability of a request.
     * @param string|null $evseStatus Filter by Locations that have the given status
     * @param string|null $connectorTypes Filter by Locations that have Connectors with the set of
     *        Connector Types
     * @param float|null $connectorMinPower Filter by Locations that have a Connector with at least
     *        this power output (in kW)
     * @param string|null $authorizationMethods Filter by Locations that support the given
     *        Authorization Methods
     * @param bool|null $withOperatorName Return operator name in marker response object
     * @param string|null $evseId optional Standard EVSE (Electric Vehicle Supply Equipment) Id
     *        identifier (ISO-IEC-15118)
     * @param string|null $locationExternalId Filter by Locations with the given externalId. (Unique
     *        Location externalID provided by Shell Recharge)
     * @param string|null $evseExternalId Filter by Locations that have an Evse with the given
     *        External Id. (Unique individual EVSE externalID provided by Shell Recharge)
     * @param int|null $pageNumber Restrict the response list by providing a specific set of page
     *        Number. Set perPage parameter also when pageNumber is used.
     * @param int|null $perPage Restrict the number of sites in reposne per page.
     * @param string|null $updatedSince ZonedDateTime as string
     *
     * @return LocationResponeObject[] Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getLocationsList(
        string $requestId,
        ?string $evseStatus = null,
        ?string $connectorTypes = null,
        ?float $connectorMinPower = null,
        ?string $authorizationMethods = null,
        ?bool $withOperatorName = null,
        ?string $evseId = null,
        ?string $locationExternalId = null,
        ?string $evseExternalId = null,
        ?int $pageNumber = null,
        ?int $perPage = null,
        ?string $updatedSince = null
    ): array {
        $_reqBuilder = $this->requestBuilder(RequestMethod::GET, '/locations/v1/ev')
            ->auth('BearerAuth')
            ->parameters(
                HeaderParam::init('RequestId', $requestId),
                QueryParam::init('evseStatus', $evseStatus)
                    ->serializeBy([GetLocationsListEvseStatusEnum::class, 'checkValue']),
                QueryParam::init('connectorTypes', $connectorTypes)
                    ->serializeBy([GetLocationsListConnectorTypesEnum::class, 'checkValue']),
                QueryParam::init('connectorMinPower', $connectorMinPower),
                QueryParam::init('authorizationMethods', $authorizationMethods)
                    ->serializeBy([GetLocationsListAuthorizationMethodsEnum::class, 'checkValue']),
                QueryParam::init('withOperatorName', $withOperatorName),
                QueryParam::init('evseId', $evseId),
                QueryParam::init('locationExternalId', $locationExternalId),
                QueryParam::init('evseExternalId', $evseExternalId),
                QueryParam::init('pageNumber', $pageNumber),
                QueryParam::init('perPage', $perPage),
                QueryParam::init('updatedSince', $updatedSince)
            );

        $_resHandler = $this->responseHandler()
            ->throwErrorOn(
                '400',
                ErrorType::init(
                    'The server cannot or will not process the request due to something that is' .
                    ' perceived to be a client error (e.g., malformed request syntax, invalid re' .
                    'quest message framing, or deceptive request routing).',
                    BadRequestException::class
                )
            )
            ->throwErrorOn(
                '401',
                ErrorType::init(
                    'The request has not been applied because it lacks valid authentication cre' .
                    'dentials for the target resource.',
                    UnauthorizedException::class
                )
            )
            ->throwErrorOn('404', ErrorType::init('Location Not Found', NotFoundException::class))
            ->type(LocationResponeObject::class, 1);

        return $this->execute($_reqBuilder, $_resHandler);
    }

    /**
     * This API provides the details on a single Shell Recharge location.
     * The query for a single location is to be made using the Unique Internal identifier used to refer to
     * this Location by Shell Recharge. (Uid from List of locations API)
     *
     * @param string $requestId A unique request id in GUID format. The value is written to the
     *        Shell API Platform audit log for end to end traceability of a request.
     * @param string $id Unique Uid of the location from List of locations API
     *
     * @return LocationResponeObject Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getLocationById(string $requestId, string $id): LocationResponeObject
    {
        $_reqBuilder = $this->requestBuilder(RequestMethod::GET, '/locations/v1/ev/{id}')
            ->auth('BearerAuth')
            ->parameters(HeaderParam::init('RequestId', $requestId), TemplateParam::init('id', $id));

        $_resHandler = $this->responseHandler()
            ->throwErrorOn(
                '400',
                ErrorType::init(
                    'The server cannot or will not process the request due to something that is' .
                    ' perceived to be a client error (e.g., malformed request syntax, invalid re' .
                    'quest message framing, or deceptive request routing).',
                    BadRequestException::class
                )
            )
            ->throwErrorOn(
                '401',
                ErrorType::init(
                    'The request has not been applied because it lacks valid authentication cre' .
                    'dentials for the target resource.',
                    UnauthorizedException::class
                )
            )
            ->throwErrorOn('404', ErrorType::init('Location Not Found', NotFoundException::class))
            ->type(LocationResponeObject::class);

        return $this->execute($_reqBuilder, $_resHandler);
    }

    /**
     * This API provides the list of all near by Shell Recharge locations based on the latitude and
     * longitude provided in the request.
     * The list includes all Shell Recharge network and all sites available through our roaming partners.
     * The end point provides the details such as the exact location/address of the site along with the up-
     * to-date status information of all the charging units in the site.
     *
     * Supported Search Options
     *
     * * Based on latitude and longitude of the location. (Mandatory)
     * * Based on status of the Charging units. Eg : Available or Occupied
     * * Based on available connector types.
     * * Based on minimum Power output (in kW) available
     *
     * @param string $requestId A unique request id in GUID format. The value is written to the
     *        Shell API Platform audit log for end to end traceability of a request.
     * @param float $latitude Latitude to get Shell Recharge Locations nearby
     * @param float $longitude Longitude to get Shell Recharge Locations nearby
     * @param float|null $limit Maximum number of Locations to retrieve
     * @param string|null $locationExternalId Filter by Locations with the given externalId
     *        Identifier as given by the Shell Recharge Operator, unique for that Operator
     * @param string|null $evseId Filter by Locations that have an Evse with the given Evse Id
     * @param string|null $evseExternalId Filter by Locations that have an Evse with the given
     *        External Id Identifier of the Evse as given by the Operator, unique for that
     *        Operator
     * @param string|null $operatorName Filter by Locations that have the given operator
     * @param string|null $evseStatus Filter by Locations that have the given status
     * @param string|null $connectorTypes Filter by Locations that have Connectors with these
     *        Connector Types
     * @param float|null $connectorMinPower Filter by Locations that have a Connector with at least
     *        this power output (in kW)
     * @param string|null $authorizationMethods Filter by Locations that support the given
     *        Authorization Methods
     * @param bool|null $withOperatorName Return operator name in marker object (only for marker
     *        type SingleChargePoint)
     * @param bool|null $withMaxPower Return maximum power in kW across all locations grouped in
     *        this marker (disregarding availability)
     *
     * @return LocationResponeObject Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getNearbyLocations(
        string $requestId,
        float $latitude,
        float $longitude,
        ?float $limit = 25,
        ?string $locationExternalId = null,
        ?string $evseId = null,
        ?string $evseExternalId = null,
        ?string $operatorName = null,
        ?string $evseStatus = null,
        ?string $connectorTypes = null,
        ?float $connectorMinPower = null,
        ?string $authorizationMethods = null,
        ?bool $withOperatorName = null,
        ?bool $withMaxPower = null
    ): LocationResponeObject {
        $_reqBuilder = $this->requestBuilder(RequestMethod::GET, '/locations/v1/ev/nearby')
            ->auth('BearerAuth')
            ->parameters(
                HeaderParam::init('RequestId', $requestId),
                QueryParam::init('latitude', $latitude),
                QueryParam::init('longitude', $longitude),
                QueryParam::init('limit', $limit),
                QueryParam::init('locationExternalId', $locationExternalId),
                QueryParam::init('evseId', $evseId),
                QueryParam::init('evseExternalId', $evseExternalId),
                QueryParam::init('operatorName', $operatorName),
                QueryParam::init('evseStatus', $evseStatus)
                    ->serializeBy([GetNearbyLocationsEvseStatusEnum::class, 'checkValue']),
                QueryParam::init('connectorTypes', $connectorTypes)
                    ->serializeBy([GetNearbyLocationsConnectorTypesEnum::class, 'checkValue']),
                QueryParam::init('connectorMinPower', $connectorMinPower),
                QueryParam::init('authorizationMethods', $authorizationMethods)
                    ->serializeBy([GetNearbyLocationsAuthorizationMethodsEnum::class, 'checkValue']),
                QueryParam::init('withOperatorName', $withOperatorName),
                QueryParam::init('withMaxPower', $withMaxPower)
            );

        $_resHandler = $this->responseHandler()
            ->throwErrorOn(
                '400',
                ErrorType::init(
                    'The server cannot or will not process the request due to something that is' .
                    ' perceived to be a client error (e.g., malformed request syntax, invalid re' .
                    'quest message framing, or deceptive request routing).',
                    BadRequestException::class
                )
            )
            ->throwErrorOn(
                '401',
                ErrorType::init(
                    'The request has not been applied because it lacks valid authentication cre' .
                    'dentials for the target resource.',
                    UnauthorizedException::class
                )
            )
            ->throwErrorOn('404', ErrorType::init('Location Not Found', NotFoundException::class))
            ->type(LocationResponeObject::class);

        return $this->execute($_reqBuilder, $_resHandler);
    }

    /**
     * This API, when given a set of bounds on the geographical front (East,West, North, South) will return
     * a set of Markers that fall within the requested bounds. The API will automatically group locations
     * at the same position on the map into one Marker.
     *
     * The API also provide further search options to filter the result set.
     *
     * * Based on status of the Charging units. Eg : Available or Occupied
     * * Based on available connector types.
     * * Based on minimum Power output (in kW) available
     *
     * @param string $requestId A unique request id in GUID format. The value is written to the
     *        Shell API Platform audit log for end to end traceability of a request.
     * @param float $west Longitude of the western bound to get the Shell Recharge Locations
     * @param float $south Latitude of the southern bound to get the Shell Recharge Locations
     * @param float $east Longitude of the eastern bound to get the Shell Recharge Locations
     * @param float $north Latitude of the northern bound to get the Shell Recharge Locations
     * @param string $zoom Zoom level to show ex: (1: World, 5: Landmass/continent, 10: City, 15:
     *        Streets, 20: Buildings)
     * @param string|null $evseStatus Filter by Locations that have the given status
     * @param string|null $connectorTypes Filter by Locations that have Connectors with the set of
     *        Connector Types
     * @param float|null $connectorMinPower Filter by Locations that have a Connector with at least
     *        this power output (in kW)
     * @param string|null $authorizationMethods Filter by Locations that support the given
     *        Authorization Methods
     * @param bool|null $withOperatorName Return operator name in marker object (only for marker
     *        type SingleChargePoint)
     * @param bool|null $withMaxPower Return maximum power in kW across all locations grouped in
     *        this marker (disregarding availability)
     * @param string|null $locationExternalId Filter by Locations with the given externalId. (Unique
     *        Location externalID provided by Shell Recharge)
     * @param string|null $evseId Filter by Locations that have an Evse with the given Evse Id
     * @param string|null $evseExternalId Filter by Locations that have an Evse with the given
     *        External Id Identifier of the Evse as given by the Operator, unique for that
     *        Operator
     * @param string|null $operatorName Filter by Locations that have the given operator
     *
     * @return array<SingleLocationMarker|MultiLocationMarker> Response from the API call
     *
     * @throws ApiException Thrown if API call fails
     */
    public function getMarkersList(
        string $requestId,
        float $west,
        float $south,
        float $east,
        float $north,
        string $zoom,
        ?string $evseStatus = null,
        ?string $connectorTypes = null,
        ?float $connectorMinPower = null,
        ?string $authorizationMethods = null,
        ?bool $withOperatorName = null,
        ?bool $withMaxPower = null,
        ?string $locationExternalId = null,
        ?string $evseId = null,
        ?string $evseExternalId = null,
        ?string $operatorName = null
    ): array {
        $_reqBuilder = $this->requestBuilder(RequestMethod::GET, '/locations/v1/ev/markers')
            ->auth('BearerAuth')
            ->parameters(
                HeaderParam::init('RequestId', $requestId),
                QueryParam::init('west', $west),
                QueryParam::init('south', $south),
                QueryParam::init('east', $east),
                QueryParam::init('north', $north),
                QueryParam::init('zoom', $zoom),
                QueryParam::init('evseStatus', $evseStatus)
                    ->serializeBy([GetMarkersListEvseStatusEnum::class, 'checkValue']),
                QueryParam::init('connectorTypes', $connectorTypes)
                    ->serializeBy([GetMarkersListConnectorTypesEnum::class, 'checkValue']),
                QueryParam::init('connectorMinPower', $connectorMinPower),
                QueryParam::init('authorizationMethods', $authorizationMethods)
                    ->serializeBy([GetMarkersListAuthorizationMethodsEnum::class, 'checkValue']),
                QueryParam::init('withOperatorName', $withOperatorName),
                QueryParam::init('withMaxPower', $withMaxPower),
                QueryParam::init('locationExternalId', $locationExternalId),
                QueryParam::init('evseId', $evseId),
                QueryParam::init('evseExternalId', $evseExternalId),
                QueryParam::init('operatorName', $operatorName)
            );

        $_resHandler = $this->responseHandler()
            ->throwErrorOn(
                '400',
                ErrorType::init(
                    'The server cannot or will not process the request due to something that is' .
                    ' perceived to be a client error (e.g., malformed request syntax, invalid re' .
                    'quest message framing, or deceptive request routing).',
                    BadRequestException::class
                )
            )
            ->throwErrorOn(
                '401',
                ErrorType::init(
                    'The request has not been applied because it lacks valid authentication cre' .
                    'dentials for the target resource.',
                    UnauthorizedException::class
                )
            )
            ->throwErrorOn('404', ErrorType::init('Location Not Found', NotFoundException::class))
            ->typeGroup(
                'oneOf{markerType}(SingleLocationMarker{singleLocation},MultiLocationMarker{multiLocation})[]'
            );

        return $this->execute($_reqBuilder, $_resHandler);
    }
}
